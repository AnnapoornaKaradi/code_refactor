locals{
	
	powerbi_source_ips = [ for v in jsondecode(data.external.powerbi_ips.result.output) : v if length(regexall(":", v)) == 0 ]
    
    fabric_source_ips = [ "20.41.4.104/31", "20.41.4.108/30", "20.41.4.208/28", "20.41.4.224/27", "20.41.5.0/25", "20.98.192.168/30", "20.98.192.192/27", "20.98.193.128/26", "20.98.193.192/29", "20.98.199.116/31", "20.119.156.32/27", "20.119.157.64/28", "74.249.120.64/26", "104.208.203.176/28", "135.232.93.144/28", "145.132.126.160/27" ]

    deploy_in = {
		allow_fabric_inbound_to_dev2 = {
			envs = [ "dev2" ]
		}
	
	}

}

/*
	NAT rules:
		*10002/10003 - nginx_maint and nginx_normal     Nginx edge translation from 80/443 inbound.  These rules flip whether DR mode is active or not.
		
	Network rules:
		10001 - allow_aks_api     Allow outbound connections from the AKS subnets to their API server load balancer
		10010 - allow_outbound_to_trusted_sftp
		10100 - block_outbound_ports
		10200 - allow_outbound_from_local_nets
		*10302 - allow_inbound_8001_and_4431
		*10303 - allow_inbound_80_and_443

	Application rules:
		10000 - allow_aks_provisioning     Allow outbound connections from AKS subnets to different endpoints used for provisioning nodes
*/

#--------------------------------- NAT rules ---------------------------------

#--------------------------------- Network rules ---------------------------------
#----- Add the necessary firewall exceptions to allow communications from the nodes to the API server
# Resolve the IP address for the AKS API load balancer
data "dns_a_record_set" "aks_api" {
	for_each = local.aks_instances

	host = azurerm_kubernetes_cluster.env[each.key].fqdn
}

#----- Get the Azure PowerBI ip ranges
data "external" "powerbi_ips" {
	program = [ "bash", "${path.module}/scripts/get_powerbi_ips.sh" ]
}


# !!!!! This will not work if a second cluster is created as the priority will be the same
resource "azurerm_firewall_network_rule_collection" "allow_aks_api" {
	for_each = local.aks_instances

	name = "allow_aks_api"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10001
	action = "Allow"
	
	rule {
		name = "allow_udp"
		
		source_addresses = local.network_info.aks_address_spaces
		
		destination_addresses = data.dns_a_record_set.aks_api[each.key].addrs
		destination_ports = [ "53", "1194", "123" ]
		
		protocols = [ "UDP" ]
	}
	
	rule {
		name = "allow_tcp"
		
		source_addresses = local.network_info.aks_address_spaces
		
		destination_addresses = data.dns_a_record_set.aks_api[each.key].addrs
		destination_ports = [ "22", "443", "9000" ]

		protocols = [ "TCP" ]
	}
}

#----- Allow AKS services to hit Fabric
resource "azurerm_firewall_network_rule_collection" "allow_aks_powerbi" {
	for_each = { for k,v in local.fabric_capacity_instances_to_install: k => v if k == "data"} ## TEMP BUG FIX

	name = "allow_aks_powerbi"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10002
	action = "Allow"
	
	rule {
		name = "allow_mssql"
		
		source_addresses = local.fabric_source_ips
		
		destination_addresses = []
		destination_ports = [ "1433" ]

		protocols = [ "TCP" ]
	}
}

#----- Allow AKS services to hit Fabric
resource "azurerm_firewall_network_rule_collection" "allow_fabric_data_powerbi" {
	name = "allow_fabric_data_powerbi"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10004
	action = "Allow"
	
	rule {
		name = "allow_mssql"
		
		source_addresses = local.network_info.aks_address_spaces
		
		destination_addresses = local.powerbi_source_ips
		destination_ports = [ "1433" ]

		protocols = [ "TCP" ]
	}
}


#------Allow fabric to hit AKS services---------
resource "azurerm_firewall_network_rule_collection" "allow_fabric_inbound_to_dev2" {
	count = contains(lookup(local.deploy_in, "allow_fabric_inbound_to_dev2", {}).envs, local.basic["local"].env_short) ? 1 : 0
	name = "allow_fabric_inbound_dev2"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10005
	action = "Allow"
	
	rule {
		name = "allow_fabric_inbound_dev2"
		
		source_addresses = local.fabric_source_ips
		
		destination_addresses = [ "20.75.16.191" ]
		destination_ports = [ "80", "443" ]

		protocols = [ "TCP" ]
	}
}

#----- Allow services to hit trusted SFTP servers
resource "azurerm_firewall_network_rule_collection" "allow_outbound_to_trusted_sftp" {
	name = "allow_outbound_to_trusted_sftp"
	
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10010
	action = "Allow"
	
	dynamic "rule" {
		for_each = local.firewall_allow_sftp_outbound
		iterator = each
		
		content {
			name = each.key
			source_addresses = local.network_info.service_address_spaces
	
			destination_addresses = each.value	
			destination_ports = [ "22" ]
		
			protocols = [ "TCP" ]
		}
	}
}
	
#----- Block known outbound ports for RPC, SQL, SMB, and SSH
resource "azurerm_firewall_network_rule_collection" "block_outbound_ports" {
	name = "block_outbound_ports"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10100
	action = "Deny"
	
	rule {
		name = "block_outbound_ports"
		
		source_addresses = [ "*" ]
		
		destination_addresses = [ "*" ]
		destination_ports = [ "135", "137", "138", "139", "1433", "1434", "445", "22" ]

		protocols = [ "TCP", "UDP" ]
	}
}

#----- Allow outbound traffic from local vNets
resource "azurerm_firewall_network_rule_collection" "allow_outbound_from_local_nets" {
	name = "allow_outbound_from_local_nets"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10200
	action = "Allow"
	
	rule {
		name = "allow_outbound_from_local_nets"
		
		source_addresses = local.network_info.local_address_spaces
		
		destination_addresses = [ "*" ]
		destination_ports = [ "*" ]
		
		protocols = [ "TCP", "UDP", "ICMP" ]
	}
}

#--------------------------------- Application rules ---------------------------------
#----- Add the necessary firewall exceptions to allow provisioning of the cluster and each node pool
# !!!!! This will not work if a second cluster is created as the priority will be the same
resource "azurerm_firewall_application_rule_collection" "allow_aks_provisioning" {
	for_each = local.aks_instances
	
	name = "allow_aks_provisioning"
	azure_firewall_name = azurerm_firewall.env["backhaul"].name
	resource_group_name = azurerm_firewall.env["backhaul"].resource_group_name
	
	priority = 10000
	action = "Allow"
	
	rule {
		name = "allow_http"
		
		source_addresses = local.network_info.aks_address_spaces
		
		target_fqdns = [
			"aksrepos.azurecr.io",
			"*blob.core.windows.net",
			"mcr.microsoft.com",
			"*cdn.mscr.io",
			"*.data.mcr.microsoft.com",
			"management.azure.com",
			"login.microsoftonline.com",
			"ntp.ubuntu.com",
			"packages.microsoft.com",
			"acs-mirror.azureedge.net"
		]
		
		protocol {
			port = "80"
			type = "Http"
		}
	}

	rule {
		name = "allow_https"
		
		source_addresses = local.network_info.aks_address_spaces
		
		target_fqdns = [
			"aksrepos.azurecr.io",
			"*blob.core.windows.net",
			"mcr.microsoft.com",
			"*cdn.mscr.io",
			"*.data.mcr.microsoft.com",
			"management.azure.com",
			"login.microsoftonline.com",
			"ntp.ubuntu.com",
			"packages.microsoft.com",
			"acs-mirror.azureedge.net"
		]
		
		protocol {
			port = "443"
			type = "Https"
		}
	}
}
